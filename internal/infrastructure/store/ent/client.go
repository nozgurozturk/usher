// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"github.com/google/uuid"
	"github.com/nozgurozturk/usher/internal/infrastructure/store/ent/migrate"

	"github.com/nozgurozturk/usher/internal/infrastructure/store/ent/event"
	"github.com/nozgurozturk/usher/internal/infrastructure/store/ent/layout"
	"github.com/nozgurozturk/usher/internal/infrastructure/store/ent/reservation"
	"github.com/nozgurozturk/usher/internal/infrastructure/store/ent/row"
	"github.com/nozgurozturk/usher/internal/infrastructure/store/ent/seat"
	"github.com/nozgurozturk/usher/internal/infrastructure/store/ent/section"
	"github.com/nozgurozturk/usher/internal/infrastructure/store/ent/ticket"
	"github.com/nozgurozturk/usher/internal/infrastructure/store/ent/user"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Event is the client for interacting with the Event builders.
	Event *EventClient
	// Layout is the client for interacting with the Layout builders.
	Layout *LayoutClient
	// Reservation is the client for interacting with the Reservation builders.
	Reservation *ReservationClient
	// Row is the client for interacting with the Row builders.
	Row *RowClient
	// Seat is the client for interacting with the Seat builders.
	Seat *SeatClient
	// Section is the client for interacting with the Section builders.
	Section *SectionClient
	// Ticket is the client for interacting with the Ticket builders.
	Ticket *TicketClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Event = NewEventClient(c.config)
	c.Layout = NewLayoutClient(c.config)
	c.Reservation = NewReservationClient(c.config)
	c.Row = NewRowClient(c.config)
	c.Seat = NewSeatClient(c.config)
	c.Section = NewSectionClient(c.config)
	c.Ticket = NewTicketClient(c.config)
	c.User = NewUserClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:         ctx,
		config:      cfg,
		Event:       NewEventClient(cfg),
		Layout:      NewLayoutClient(cfg),
		Reservation: NewReservationClient(cfg),
		Row:         NewRowClient(cfg),
		Seat:        NewSeatClient(cfg),
		Section:     NewSectionClient(cfg),
		Ticket:      NewTicketClient(cfg),
		User:        NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:         ctx,
		config:      cfg,
		Event:       NewEventClient(cfg),
		Layout:      NewLayoutClient(cfg),
		Reservation: NewReservationClient(cfg),
		Row:         NewRowClient(cfg),
		Seat:        NewSeatClient(cfg),
		Section:     NewSectionClient(cfg),
		Ticket:      NewTicketClient(cfg),
		User:        NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Event.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Event.Use(hooks...)
	c.Layout.Use(hooks...)
	c.Reservation.Use(hooks...)
	c.Row.Use(hooks...)
	c.Seat.Use(hooks...)
	c.Section.Use(hooks...)
	c.Ticket.Use(hooks...)
	c.User.Use(hooks...)
}

// EventClient is a client for the Event schema.
type EventClient struct {
	config
}

// NewEventClient returns a client for the Event from the given config.
func NewEventClient(c config) *EventClient {
	return &EventClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `event.Hooks(f(g(h())))`.
func (c *EventClient) Use(hooks ...Hook) {
	c.hooks.Event = append(c.hooks.Event, hooks...)
}

// Create returns a create builder for Event.
func (c *EventClient) Create() *EventCreate {
	mutation := newEventMutation(c.config, OpCreate)
	return &EventCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Event entities.
func (c *EventClient) CreateBulk(builders ...*EventCreate) *EventCreateBulk {
	return &EventCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Event.
func (c *EventClient) Update() *EventUpdate {
	mutation := newEventMutation(c.config, OpUpdate)
	return &EventUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventClient) UpdateOne(e *Event) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEvent(e))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventClient) UpdateOneID(id uuid.UUID) *EventUpdateOne {
	mutation := newEventMutation(c.config, OpUpdateOne, withEventID(id))
	return &EventUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Event.
func (c *EventClient) Delete() *EventDelete {
	mutation := newEventMutation(c.config, OpDelete)
	return &EventDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *EventClient) DeleteOne(e *Event) *EventDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *EventClient) DeleteOneID(id uuid.UUID) *EventDeleteOne {
	builder := c.Delete().Where(event.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventDeleteOne{builder}
}

// Query returns a query builder for Event.
func (c *EventClient) Query() *EventQuery {
	return &EventQuery{
		config: c.config,
	}
}

// Get returns a Event entity by its id.
func (c *EventClient) Get(ctx context.Context, id uuid.UUID) (*Event, error) {
	return c.Query().Where(event.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventClient) GetX(ctx context.Context, id uuid.UUID) *Event {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryReservations queries the reservations edge of a Event.
func (c *EventClient) QueryReservations(e *Event) *ReservationQuery {
	query := &ReservationQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(reservation.Table, reservation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event.ReservationsTable, event.ReservationsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTickets queries the tickets edge of a Event.
func (c *EventClient) QueryTickets(e *Event) *TicketQuery {
	query := &TicketQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(ticket.Table, ticket.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, event.TicketsTable, event.TicketsColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLayout queries the layout edge of a Event.
func (c *EventClient) QueryLayout(e *Event) *LayoutQuery {
	query := &LayoutQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(event.Table, event.FieldID, id),
			sqlgraph.To(layout.Table, layout.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, event.LayoutTable, event.LayoutColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EventClient) Hooks() []Hook {
	return c.hooks.Event
}

// LayoutClient is a client for the Layout schema.
type LayoutClient struct {
	config
}

// NewLayoutClient returns a client for the Layout from the given config.
func NewLayoutClient(c config) *LayoutClient {
	return &LayoutClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `layout.Hooks(f(g(h())))`.
func (c *LayoutClient) Use(hooks ...Hook) {
	c.hooks.Layout = append(c.hooks.Layout, hooks...)
}

// Create returns a create builder for Layout.
func (c *LayoutClient) Create() *LayoutCreate {
	mutation := newLayoutMutation(c.config, OpCreate)
	return &LayoutCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Layout entities.
func (c *LayoutClient) CreateBulk(builders ...*LayoutCreate) *LayoutCreateBulk {
	return &LayoutCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Layout.
func (c *LayoutClient) Update() *LayoutUpdate {
	mutation := newLayoutMutation(c.config, OpUpdate)
	return &LayoutUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LayoutClient) UpdateOne(l *Layout) *LayoutUpdateOne {
	mutation := newLayoutMutation(c.config, OpUpdateOne, withLayout(l))
	return &LayoutUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LayoutClient) UpdateOneID(id uuid.UUID) *LayoutUpdateOne {
	mutation := newLayoutMutation(c.config, OpUpdateOne, withLayoutID(id))
	return &LayoutUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Layout.
func (c *LayoutClient) Delete() *LayoutDelete {
	mutation := newLayoutMutation(c.config, OpDelete)
	return &LayoutDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *LayoutClient) DeleteOne(l *Layout) *LayoutDeleteOne {
	return c.DeleteOneID(l.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *LayoutClient) DeleteOneID(id uuid.UUID) *LayoutDeleteOne {
	builder := c.Delete().Where(layout.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LayoutDeleteOne{builder}
}

// Query returns a query builder for Layout.
func (c *LayoutClient) Query() *LayoutQuery {
	return &LayoutQuery{
		config: c.config,
	}
}

// Get returns a Layout entity by its id.
func (c *LayoutClient) Get(ctx context.Context, id uuid.UUID) (*Layout, error) {
	return c.Query().Where(layout.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LayoutClient) GetX(ctx context.Context, id uuid.UUID) *Layout {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvents queries the events edge of a Layout.
func (c *LayoutClient) QueryEvents(l *Layout) *EventQuery {
	query := &EventQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(layout.Table, layout.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, layout.EventsTable, layout.EventsColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySections queries the sections edge of a Layout.
func (c *LayoutClient) QuerySections(l *Layout) *SectionQuery {
	query := &SectionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := l.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(layout.Table, layout.FieldID, id),
			sqlgraph.To(section.Table, section.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, layout.SectionsTable, layout.SectionsColumn),
		)
		fromV = sqlgraph.Neighbors(l.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LayoutClient) Hooks() []Hook {
	return c.hooks.Layout
}

// ReservationClient is a client for the Reservation schema.
type ReservationClient struct {
	config
}

// NewReservationClient returns a client for the Reservation from the given config.
func NewReservationClient(c config) *ReservationClient {
	return &ReservationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `reservation.Hooks(f(g(h())))`.
func (c *ReservationClient) Use(hooks ...Hook) {
	c.hooks.Reservation = append(c.hooks.Reservation, hooks...)
}

// Create returns a create builder for Reservation.
func (c *ReservationClient) Create() *ReservationCreate {
	mutation := newReservationMutation(c.config, OpCreate)
	return &ReservationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Reservation entities.
func (c *ReservationClient) CreateBulk(builders ...*ReservationCreate) *ReservationCreateBulk {
	return &ReservationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Reservation.
func (c *ReservationClient) Update() *ReservationUpdate {
	mutation := newReservationMutation(c.config, OpUpdate)
	return &ReservationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReservationClient) UpdateOne(r *Reservation) *ReservationUpdateOne {
	mutation := newReservationMutation(c.config, OpUpdateOne, withReservation(r))
	return &ReservationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReservationClient) UpdateOneID(id uuid.UUID) *ReservationUpdateOne {
	mutation := newReservationMutation(c.config, OpUpdateOne, withReservationID(id))
	return &ReservationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Reservation.
func (c *ReservationClient) Delete() *ReservationDelete {
	mutation := newReservationMutation(c.config, OpDelete)
	return &ReservationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ReservationClient) DeleteOne(r *Reservation) *ReservationDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ReservationClient) DeleteOneID(id uuid.UUID) *ReservationDeleteOne {
	builder := c.Delete().Where(reservation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReservationDeleteOne{builder}
}

// Query returns a query builder for Reservation.
func (c *ReservationClient) Query() *ReservationQuery {
	return &ReservationQuery{
		config: c.config,
	}
}

// Get returns a Reservation entity by its id.
func (c *ReservationClient) Get(ctx context.Context, id uuid.UUID) (*Reservation, error) {
	return c.Query().Where(reservation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReservationClient) GetX(ctx context.Context, id uuid.UUID) *Reservation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryEvent queries the event edge of a Reservation.
func (c *ReservationClient) QueryEvent(r *Reservation) *EventQuery {
	query := &EventQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(reservation.Table, reservation.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, reservation.EventTable, reservation.EventColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Reservation.
func (c *ReservationClient) QueryUser(r *Reservation) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(reservation.Table, reservation.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, reservation.UserTable, reservation.UserColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReservationClient) Hooks() []Hook {
	return c.hooks.Reservation
}

// RowClient is a client for the Row schema.
type RowClient struct {
	config
}

// NewRowClient returns a client for the Row from the given config.
func NewRowClient(c config) *RowClient {
	return &RowClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `row.Hooks(f(g(h())))`.
func (c *RowClient) Use(hooks ...Hook) {
	c.hooks.Row = append(c.hooks.Row, hooks...)
}

// Create returns a create builder for Row.
func (c *RowClient) Create() *RowCreate {
	mutation := newRowMutation(c.config, OpCreate)
	return &RowCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Row entities.
func (c *RowClient) CreateBulk(builders ...*RowCreate) *RowCreateBulk {
	return &RowCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Row.
func (c *RowClient) Update() *RowUpdate {
	mutation := newRowMutation(c.config, OpUpdate)
	return &RowUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RowClient) UpdateOne(r *Row) *RowUpdateOne {
	mutation := newRowMutation(c.config, OpUpdateOne, withRow(r))
	return &RowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RowClient) UpdateOneID(id uuid.UUID) *RowUpdateOne {
	mutation := newRowMutation(c.config, OpUpdateOne, withRowID(id))
	return &RowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Row.
func (c *RowClient) Delete() *RowDelete {
	mutation := newRowMutation(c.config, OpDelete)
	return &RowDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *RowClient) DeleteOne(r *Row) *RowDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *RowClient) DeleteOneID(id uuid.UUID) *RowDeleteOne {
	builder := c.Delete().Where(row.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RowDeleteOne{builder}
}

// Query returns a query builder for Row.
func (c *RowClient) Query() *RowQuery {
	return &RowQuery{
		config: c.config,
	}
}

// Get returns a Row entity by its id.
func (c *RowClient) Get(ctx context.Context, id uuid.UUID) (*Row, error) {
	return c.Query().Where(row.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RowClient) GetX(ctx context.Context, id uuid.UUID) *Row {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySection queries the section edge of a Row.
func (c *RowClient) QuerySection(r *Row) *SectionQuery {
	query := &SectionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(row.Table, row.FieldID, id),
			sqlgraph.To(section.Table, section.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, row.SectionTable, row.SectionColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySeats queries the seats edge of a Row.
func (c *RowClient) QuerySeats(r *Row) *SeatQuery {
	query := &SeatQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(row.Table, row.FieldID, id),
			sqlgraph.To(seat.Table, seat.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, row.SeatsTable, row.SeatsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RowClient) Hooks() []Hook {
	return c.hooks.Row
}

// SeatClient is a client for the Seat schema.
type SeatClient struct {
	config
}

// NewSeatClient returns a client for the Seat from the given config.
func NewSeatClient(c config) *SeatClient {
	return &SeatClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `seat.Hooks(f(g(h())))`.
func (c *SeatClient) Use(hooks ...Hook) {
	c.hooks.Seat = append(c.hooks.Seat, hooks...)
}

// Create returns a create builder for Seat.
func (c *SeatClient) Create() *SeatCreate {
	mutation := newSeatMutation(c.config, OpCreate)
	return &SeatCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Seat entities.
func (c *SeatClient) CreateBulk(builders ...*SeatCreate) *SeatCreateBulk {
	return &SeatCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Seat.
func (c *SeatClient) Update() *SeatUpdate {
	mutation := newSeatMutation(c.config, OpUpdate)
	return &SeatUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SeatClient) UpdateOne(s *Seat) *SeatUpdateOne {
	mutation := newSeatMutation(c.config, OpUpdateOne, withSeat(s))
	return &SeatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SeatClient) UpdateOneID(id uuid.UUID) *SeatUpdateOne {
	mutation := newSeatMutation(c.config, OpUpdateOne, withSeatID(id))
	return &SeatUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Seat.
func (c *SeatClient) Delete() *SeatDelete {
	mutation := newSeatMutation(c.config, OpDelete)
	return &SeatDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *SeatClient) DeleteOne(s *Seat) *SeatDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *SeatClient) DeleteOneID(id uuid.UUID) *SeatDeleteOne {
	builder := c.Delete().Where(seat.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SeatDeleteOne{builder}
}

// Query returns a query builder for Seat.
func (c *SeatClient) Query() *SeatQuery {
	return &SeatQuery{
		config: c.config,
	}
}

// Get returns a Seat entity by its id.
func (c *SeatClient) Get(ctx context.Context, id uuid.UUID) (*Seat, error) {
	return c.Query().Where(seat.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SeatClient) GetX(ctx context.Context, id uuid.UUID) *Seat {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTickets queries the tickets edge of a Seat.
func (c *SeatClient) QueryTickets(s *Seat) *TicketQuery {
	query := &TicketQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(seat.Table, seat.FieldID, id),
			sqlgraph.To(ticket.Table, ticket.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, seat.TicketsTable, seat.TicketsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRows queries the rows edge of a Seat.
func (c *SeatClient) QueryRows(s *Seat) *RowQuery {
	query := &RowQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(seat.Table, seat.FieldID, id),
			sqlgraph.To(row.Table, row.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, seat.RowsTable, seat.RowsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SeatClient) Hooks() []Hook {
	return c.hooks.Seat
}

// SectionClient is a client for the Section schema.
type SectionClient struct {
	config
}

// NewSectionClient returns a client for the Section from the given config.
func NewSectionClient(c config) *SectionClient {
	return &SectionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `section.Hooks(f(g(h())))`.
func (c *SectionClient) Use(hooks ...Hook) {
	c.hooks.Section = append(c.hooks.Section, hooks...)
}

// Create returns a create builder for Section.
func (c *SectionClient) Create() *SectionCreate {
	mutation := newSectionMutation(c.config, OpCreate)
	return &SectionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Section entities.
func (c *SectionClient) CreateBulk(builders ...*SectionCreate) *SectionCreateBulk {
	return &SectionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Section.
func (c *SectionClient) Update() *SectionUpdate {
	mutation := newSectionMutation(c.config, OpUpdate)
	return &SectionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SectionClient) UpdateOne(s *Section) *SectionUpdateOne {
	mutation := newSectionMutation(c.config, OpUpdateOne, withSection(s))
	return &SectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SectionClient) UpdateOneID(id uuid.UUID) *SectionUpdateOne {
	mutation := newSectionMutation(c.config, OpUpdateOne, withSectionID(id))
	return &SectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Section.
func (c *SectionClient) Delete() *SectionDelete {
	mutation := newSectionMutation(c.config, OpDelete)
	return &SectionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *SectionClient) DeleteOne(s *Section) *SectionDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *SectionClient) DeleteOneID(id uuid.UUID) *SectionDeleteOne {
	builder := c.Delete().Where(section.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SectionDeleteOne{builder}
}

// Query returns a query builder for Section.
func (c *SectionClient) Query() *SectionQuery {
	return &SectionQuery{
		config: c.config,
	}
}

// Get returns a Section entity by its id.
func (c *SectionClient) Get(ctx context.Context, id uuid.UUID) (*Section, error) {
	return c.Query().Where(section.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SectionClient) GetX(ctx context.Context, id uuid.UUID) *Section {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryLayout queries the layout edge of a Section.
func (c *SectionClient) QueryLayout(s *Section) *LayoutQuery {
	query := &LayoutQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(section.Table, section.FieldID, id),
			sqlgraph.To(layout.Table, layout.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, section.LayoutTable, section.LayoutColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRows queries the rows edge of a Section.
func (c *SectionClient) QueryRows(s *Section) *RowQuery {
	query := &RowQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(section.Table, section.FieldID, id),
			sqlgraph.To(row.Table, row.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, section.RowsTable, section.RowsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SectionClient) Hooks() []Hook {
	return c.hooks.Section
}

// TicketClient is a client for the Ticket schema.
type TicketClient struct {
	config
}

// NewTicketClient returns a client for the Ticket from the given config.
func NewTicketClient(c config) *TicketClient {
	return &TicketClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ticket.Hooks(f(g(h())))`.
func (c *TicketClient) Use(hooks ...Hook) {
	c.hooks.Ticket = append(c.hooks.Ticket, hooks...)
}

// Create returns a create builder for Ticket.
func (c *TicketClient) Create() *TicketCreate {
	mutation := newTicketMutation(c.config, OpCreate)
	return &TicketCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Ticket entities.
func (c *TicketClient) CreateBulk(builders ...*TicketCreate) *TicketCreateBulk {
	return &TicketCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Ticket.
func (c *TicketClient) Update() *TicketUpdate {
	mutation := newTicketMutation(c.config, OpUpdate)
	return &TicketUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TicketClient) UpdateOne(t *Ticket) *TicketUpdateOne {
	mutation := newTicketMutation(c.config, OpUpdateOne, withTicket(t))
	return &TicketUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TicketClient) UpdateOneID(id uuid.UUID) *TicketUpdateOne {
	mutation := newTicketMutation(c.config, OpUpdateOne, withTicketID(id))
	return &TicketUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Ticket.
func (c *TicketClient) Delete() *TicketDelete {
	mutation := newTicketMutation(c.config, OpDelete)
	return &TicketDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *TicketClient) DeleteOne(t *Ticket) *TicketDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *TicketClient) DeleteOneID(id uuid.UUID) *TicketDeleteOne {
	builder := c.Delete().Where(ticket.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TicketDeleteOne{builder}
}

// Query returns a query builder for Ticket.
func (c *TicketClient) Query() *TicketQuery {
	return &TicketQuery{
		config: c.config,
	}
}

// Get returns a Ticket entity by its id.
func (c *TicketClient) Get(ctx context.Context, id uuid.UUID) (*Ticket, error) {
	return c.Query().Where(ticket.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TicketClient) GetX(ctx context.Context, id uuid.UUID) *Ticket {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySeat queries the seat edge of a Ticket.
func (c *TicketClient) QuerySeat(t *Ticket) *SeatQuery {
	query := &SeatQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ticket.Table, ticket.FieldID, id),
			sqlgraph.To(seat.Table, seat.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ticket.SeatTable, ticket.SeatColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEvent queries the event edge of a Ticket.
func (c *TicketClient) QueryEvent(t *Ticket) *EventQuery {
	query := &EventQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ticket.Table, ticket.FieldID, id),
			sqlgraph.To(event.Table, event.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ticket.EventTable, ticket.EventColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Ticket.
func (c *TicketClient) QueryUser(t *Ticket) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ticket.Table, ticket.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ticket.UserTable, ticket.UserColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TicketClient) Hooks() []Hook {
	return c.hooks.Ticket
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Create returns a create builder for User.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uuid.UUID) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *UserClient) DeleteOneID(id uuid.UUID) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uuid.UUID) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uuid.UUID) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryReservations queries the reservations edge of a User.
func (c *UserClient) QueryReservations(u *User) *ReservationQuery {
	query := &ReservationQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(reservation.Table, reservation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ReservationsTable, user.ReservationsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTickets queries the tickets edge of a User.
func (c *UserClient) QueryTickets(u *User) *TicketQuery {
	query := &TicketQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(ticket.Table, ticket.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.TicketsTable, user.TicketsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}
